68 61 42 -> position at the door of severino's cell
3A 34 0F -> position at the entrance of the hallway through which you go to the stairs leading up to the library

; copied at 0x10b-0x10d. State and predefined positions of berengario
3CE7: FA 00 00
	8C 48 42 -> church
	32 35 C2 -> refectory
	3D 5C 8F -> his desk in the scriptorium
	BC 15 02 -> monks' cell
	88 A8 C0 -> abbey exit
	52 67 04 -> position at the foot of the stairs to go up to the scriptorium
	68 57 02 -> severino's cell

; copied at 0x10e-0x110. State and predefined positions of severino/jorge
3CFF: FA 00 00
	8C 4B 42 -> church
	36 35 C2 -> refectory
	68 55 02 -> berengario's cell
	C9 2A 00 -> near the monks' cells
	19 2B 1A -> room where jorge dies

; copied at 0x111-0x113. State and predefined positions of adso
3D11: FF 00 00
3D14:	84 4E 42 -> church
		34 39 42 -> refectory
		A8 18 00 -> guillermo's cell

; table of association of constants to important memory addresses for the program (used by the script system)
3D1D: 	[0x3038] -> 0x00 (0x80) -> guillermo's x position
		[0x3039] -> 0x01 (0x81) -> guillermo's y position
		[0x303a] -> 0x02 (0x82) -> guillermo's height
		[0x3047] -> 0x03 (0x83) -> adso's x position
		[0x3075] -> 0x04 (0x84) -> berengario's x position
		[0x3049] -> 0x05 (0x85) -> adso's height
		[0x3caa] -> 0x06 (0x86) -> where malaquias is going
		[0x3ca8] -> 0x07 (0x87) -> where malaquias has arrived
		[0x2d81] -> 0x08 (0x88) -> time of day
		[0x2da1] -> 0x09 (0x89) -> indicates if a phrase is being played
		[0x3cc6] -> 0x0a (0x8a) -> where the abbot has arrived
		[0x3cc8] -> 0x0b (0x8b) -> where the abbot is going
		[0x3cc7] -> 0x0c (0x8c) -> abbot's state
		[0x2d80] -> 0x0d (0x8d) -> day number
		[0x3ca9] -> 0x0e (0x8e) -> malaquias' state
		[0x3c9e] -> 0x0f (0x8f) -> counter used to see how long guillermo is in the scriptorium without obeying
		[0x3ce9] -> 0x10 (0x90) -> where berengario is going
		[0x3ce7] -> 0x11 (0x91) -> where berengario has arrived
		[0x3ce8] -> 0x12 (0x92) -> berengario's state
		[0x3d01] -> 0x13 (0x93) -> where severino is going
		[0x3cff] -> 0x14 (0x94) -> where severino has arrived
		[0x3d00] -> 0x15 (0x95) -> severino's state
		[0x3d13] -> 0x16 (0x96) -> where adso is going
		[0x3d11] -> 0x17 (0x97) -> where adso has arrived
		[0x3d12] -> 0x18 (0x98) -> adso's state
		[0x3c98] -> 0x19 (0x99) -> counter
		[0x2dbd] -> 0x1a (0x9a) -> indicates the screen number shown by the camera
		[0x3c9a] -> 0x1b (0x9b) -> indicates if the time of day should advance
		[0x3c97] -> 0x1c (0x9c) -> indicates if guillermo has died
		[0x3074] -> 0x1d (0x9d) -> x position of berengario/bernardo gui/hooded/jorge
		[0x3ca6] -> 0x1e (0x9e) -> mask for the doors where each bit indicates which door is checked if it opens
		[0x2ffe] -> 0x1f (0x9f) -> number and state of door 1 that blocks passage to the left wing of the abbey
		[0x3003] -> 0x20 (0xa0) -> number and state of door 2 that blocks passage to the left wing of the abbey
		[0x3c99] -> 0x21 (0xa1) -> counter of guillermo's response time to adso's question about sleeping
		[0x3f0e] -> 0x22 (0xa2) -> modifies the phrase shown by routine 0x3f0b
		[0x3c96] -> 0x23 (0xa3) -> indicates if they are ready to start the mass/meal
		[0x2def] -> 0x24 (0xa4) -> objects guillermo has
		[0x3c94] -> 0x25 (0xa5) -> indicates that berengario has told the abbot that guillermo has taken the parchment
		[0x2e04] -> 0x26 (0xa6) -> objects the abbot has
		[0x3c92] -> 0x27 (0xa7) -> character followed by the camera if no keys are pressed for a while
		[0x2e0b] -> 0x28 (0xa8) -> berengario's objects
		[0x0840] -> 0x29 (0xa9) -> ??? not used ???
		[0x3c95] -> 0x2a (0xaa) -> indicates the time of day of the last executed actions
		[0x3ca1] -> 0x2b (0xab) -> indicates that jorge or bernardo gui are active for berengario's thinking routine
		[0x3ca2] -> 0x2c (0xac) -> indicates if malaquias is dead or dying
		[0x3ca3] -> 0x2d (0xad) -> indicates that jorge is active for severino's thinking routine
		[0x3ca5] -> 0x2e (0xae) -> more state information for severino, berengario and malaquias
		[0x3c9b] -> 0x2f (0xaf) -> indicates if guillermo is in his place in the refectory or at mass
		[0x2e0d] -> 0x30 (0xb0) -> mask with objects that berengario/bernardo gui can pick up
		[0x3ca4] -> 0x31 (0xb1) -> ???
		[0x3c9d] -> 0x32 (0xb2) -> random value obtained from adso's movements
		[0x3c90] -> 0x33 (0xb3) -> indicates that the parchment is held by the abbot in his room or is behind the mirror room
		[0x3c8c] -> 0x34 (0xb4) -> if the night is ending, it is set to 1. Otherwise, it is set to 0
		[0x3c8d] -> 0x35 (0xb5) -> indicates lamp state changes
		[0x3c8e] -> 0x36 (0xb6) -> counter of time they can go in the dark through the library
		[0x3c8b] -> 0x37 (0xb7) -> indicates that the lamp is being used
		[0x2df3] -> 0x38 (0xb8) -> indicates if adso has the lamp
		[0x3ca7] -> 0x39 (0xb9) -> if it is 0, indicates that the investigation has been completed
		[0x2dff] -> 0x3a (0xba) -> mask with objects that malaquias can pick up
		[0x2dfd] -> 0x3b (0xbb) -> malaquias' objects
		[0x416e] -> 0x3c (0xbc) -> ???
		[0x3c85] -> 0x3d (0xbd) -> counter used to kill guillermo if he reads the book without gloves
		[0x2df6] -> 0x3e (0xbe) -> adso's objects
		[0x2dbe] -> 0x3f (0xbf) -> indicates bonuses obtained 1
		[0x2dbf] -> 0x40 (0xc0) -> indicates bonuses obtained 2

; table of values for computing distance between characters, indexed by character orientation.
; Each entry has 4 bytes
; byte 0: value to add to the character's x distance
; byte 1: threshold value to say the character is near in x
; byte 2: value to add to the character's y distance
; byte 3: threshold value to say the character is near in y
3D9F: 	06 18 06 0C -> used when character orientation is 0 (facing towards +x)
		06 0C 0C 18 -> used when character orientation is 1 (facing towards -y)
		0C 18 06 0C -> used when character orientation is 2 (facing towards -x)
		06 0C 06 18 -> used when character orientation is 3 (facing towards +y)

; takes values from the return address, interpreting those values (reads related memory positions, performs calculations between
; them until finding a jump or call instruction, and updating the first related memory position) (called by rst 0x10)
3DAF: E1          pop  hl			; gets the return address
3DB0: 7E          ld   a,(hl)		; reads the first value
3DB1: 23          inc  hl
3DB2: E5          push hl
3DB3: CD C3 3D    call $3DC3		; gets in hl an address that is in [0x3d1d + 2*a]
3DB6: 22 C0 3D    ld   ($3DC0),hl	; sets the instruction parameter with the address read
3DB9: E1          pop  hl
3DBA: CD D9 3D    call $3DD9		; processes the string of bytes to see if it processes any instruction modifying c
3DBD: E5          push hl
3DBE: 79          ld   a,c			; writes the value read to the address
3DBF: 32 00 00    ld   ($0000),a	; modified from outside
3DC2: C9          ret

; gets in hl an address that is in 0x3d1d + 2*a (removing the upper bit)
3DC3: 87          add  a,a			; removes the upper bit and indexes (each entry is 2 bytes)
3DC4: 21 1D 3D    ld   hl,$3D1D		; points to the address table
3DC7: 85          add  a,l			; hl = hl + 2*a
3DC8: 6F          ld   l,a
3DC9: 8C          adc  a,h
3DCA: 95          sub  l
3DCB: 67          ld   h,a

3DCC: 5E          ld   e,(hl)		; de = [hl]
3DCD: 23          inc  hl
3DCE: 56          ld   d,(hl)
3DCF: EB          ex   de,hl
3DD0: C9          ret

; takes values from the return address, interpreting those values (reads related memory positions and performs
;  calculations between them until finding a jump or call instruction) (called by rst 0x08)
3DD1: E1          pop  hl			; hl = return address
3DD2: CD D9 3D    call $3DD9		; processes the string of bytes to see if it processes any instruction modifying c
3DD5: E5          push hl			; sets the return address after the bytes it has processed
3DD6: 79          ld   a,c			; returns if c != 0
3DD7: A7          and  a
3DD8: C9          ret

3DD9: CD 47 3E    call $3E47		; returns data (in c) related to what is at hl and advances hl

3DDC: 7E          ld   a,(hl)		; if the next instruction to execute at hl is:
3DDD: FE 20       cp   $20			;  jr nz,$xxxx, rst 0x10, jp nz,$xxxx, call $xxxxx, rst 0x08, ret, jp $xxxx, jr $xxxx
3DDF: C8          ret  z			;  exits the routine (evaluation finished)
3DE0: FE D7       cp   $D7
3DE2: C8          ret  z
3DE3: FE C2       cp   $C2
3DE5: C8          ret  z
3DE6: FE CD       cp   $CD
3DE8: C8          ret  z
3DE9: FE CF       cp   $CF
3DEB: C8          ret  z
3DEC: FE C9       cp   $C9
3DEE: C8          ret  z
3DEF: FE C3       cp   $C3
3DF1: C8          ret  z
3DF2: FE 18       cp   $18
3DF4: C8          ret  z

; if it reaches here, another operand needs to be read or an instruction executed between 2 operands
3DF5: 23          inc  hl			; advances the data pointer
3DF6: D1          pop  de			; recovers the possible last calculated value
3DF7: FE 3D       cp   $3D			; if any match is found with the operations, jump
3DF9: 28 43       jr   z,$3E3E		; 0x3d (char '=') -> c = c1 == c2
3DFB: FE 3E       cp   $3E
3DFD: 28 2D       jr   z,$3E2C		; 0x3e (char '>') -> c = c1 >= c2
3DFF: FE 3C       cp   $3C
3E01: 28 32       jr   z,$3E35		; 0x3c (char '<') -> c = c1 < c2
3E03: FE 2A       cp   $2A
3E05: 28 21       jr   z,$3E28		; 0x2a (char '*') -> c = c1 | c2 between booleans, c = c1 & c2 between values
3E07: FE 26       cp   $26
3E09: 28 19       jr   z,$3E24		; 0x26 (char '&') -> c = c1 & c2 between booleans, c = c1 | c2 between values
3E0B: FE 2B       cp   $2B
3E0D: 28 11       jr   z,$3E20		; 0x2b (char '+') -> c = c1 + c2
3E0F: FE 2D       cp   $2D
3E11: 28 08       jr   z,$3E1B		; 0x2d (char '-') -> c = c1 - c2

; if it reaches here, it's because no operation had to be executed
3E13: D5          push de			; saves the return address (since it's not an operand)
3E14: C5          push bc			; saves the last operand obtained
3E15: 2B          dec  hl			; moves the data pointer back
3E16: CD 47 3E    call $3E47		; returns data related to what is at hl and advances hl
3E19: 18 C1       jr   $3DDC		; returns to check the cases

; jumps here if it finds 0x2d (c = c1 - c2)
3E1B: 7B          ld   a,e
3E1C: 91          sub  c

3E1D: 4F          ld   c,a
3E1E: 18 BC       jr   $3DDC

; jumps here if it finds 0x2b (c = c1 + c2)
3E20: 79          ld   a,c
3E21: 83          add  a,e
3E22: 18 F9       jr   $3E1D

; jumps here if it finds 0x26 (c = c1 & c2 between booleans, c1 | c2 between values)
3E24: 79          ld   a,c
3E25: B3          or   e
3E26: 18 F5       jr   $3E1D

; jumps here if it finds 0x2a (c = c1 | c2 between booleans, c1 & c2 between values)
3E28: 79          ld   a,c
3E29: A3          and  e
3E2A: 18 F1       jr   $3E1D

; jumps here if it finds 0x3e (if c1 >= c2, c = 0, otherwise, c = 0xff)
3E2C: 7B          ld   a,e		; a = c1
3E2D: B9          cp   c		; compares it with c2
3E2E: 0E 00       ld   c,$00
3E30: 30 AA       jr   nc,$3DDC	; if c1 >= c2, jumps
3E32: 0D          dec  c
3E33: 18 A7       jr   $3DDC

; jumps here if it finds 0x3c (if c1 < c2, c = 0, otherwise, c = 0xff)
3E35: 7B          ld   a,e		; a = c1
3E36: B9          cp   c		; compares it with c2
3E37: 0E 00       ld   c,$00
3E39: 38 A1       jr   c,$3DDC	; if c2 > c1, jumps
3E3B: 0D          dec  c
3E3C: 18 9E       jr   $3DDC

; jumps here if it finds 0x3d (if c1 = c2, c = 0, otherwise, c = 0xff)
3E3E: 79          ld   a,c		; a = c2
3E3F: 0E 00       ld   c,$00
3E41: BB          cp   e		; is it equal to c1?
3E42: 28 98       jr   z,$3DDC
3E44: 0D          dec  c
3E45: 18 95       jr   $3DDC

; returns in c data related to what is at hl and advances hl. Used to obtain values from important program addresses for
;  the script system
;  if it's 0x40, returns [hl+1]. if it's < 0x80, returns [hl]. Otherwise, returns [0x3d1d + 2*[hl]]
3E47: 7E          ld   a,(hl)		; reads data
3E48: 23          inc  hl
3E49: FE 40       cp   $40			; if it's not 0x40, jumps
3E4B: 20 03       jr   nz,$3E50
3E4D: 4E          ld   c,(hl)		; if it's 0x40, returns the data that came after (used to return data >= 0x80 or data that has)
3E4E: 23          inc  hl			;  the same value as any of the instructions that stop the interpreter
3E4F: C9          ret

3E50: FE 80       cp   $80			; if it's < 0x80, exits returning the data that was read
3E52: 4F          ld   c,a
3E53: D8          ret  c
3E54: E5          push hl
3E55: CD C3 3D    call $3DC3		; gets in hl an address that is in the script constant association table
3E58: 4E          ld   c,(hl)		; returns a value from that address
3E59: E1          pop  hl
3E5A: C9          ret

; ----------------- end of code related to character behavior interpreter -----------------------------

; indicates that the character doesn't want to search for any path
3E5B: 3E 01       ld   a,$01
3E5D: 32 9C 3C    ld   ($3C9C),a
3E60: C9          ret

; compares the distance between guillermo and the character passed in iy
; if very close, returns 0, otherwise returns something != 0
; parameters: iy = character data
3E61: 3A 3A 30    ld   a,($303A)	; a = guillermo's height
3E64: CD 73 24    call $2473		; b = base height of the floor guillermo is on
3E67: 68          ld   l,b
3E68: FD 7E 04    ld   a,(iy+$04)	; a = character's height
3E6B: CD 73 24    call $2473		; b = base height of the floor the character is on
3E6E: 78          ld   a,b
3E6F: BD          cp   l
3E70: C0          ret  nz			; if the characters are not on the same floor, exits
3E71: FD 7E 01    ld   a,(iy+$01)	; gets the character's orientation
3E74: 87          add  a,a			; each entry occupies 4 bytes
3E75: 87          add  a,a
3E76: 21 9F 3D    ld   hl,$3D9F		; indexes the table of permissible distance values according to orientation
3E79: CD 2D 16    call $162D		; hl = hl + a
3E7C: 3A 38 30    ld   a,($3038)	; gets guillermo's x position
3E7F: 86          add  a,(hl)		; adds a constant according to orientation
3E80: 23          inc  hl
3E81: FD 96 02    sub  (iy+$02)		; subtracts the character's x position
3E84: BE          cp   (hl)
3E85: 30 0E       jr   nc,$3E95		; if the x distance between the abbot's position and guillermo exceeds the threshold, jumps
3E87: 23          inc  hl
3E88: 3A 39 30    ld   a,($3039)	; gets guillermo's y position
3E8B: 86          add  a,(hl)		; adds a constant according to orientation
3E8C: 23          inc  hl
3E8D: FD 96 03    sub  (iy+$03)		; subtracts the character's y position
3E90: BE          cp   (hl)
3E91: 30 02       jr   nc,$3E95		; if the y distance between the character's position and guillermo exceeds the threshold, jumps
3E93: AF          xor  a			; returns 0
3E94: C9          ret

3E95: F6 FF       or   $FF
3E97: C9          ret

; if has arrived at the place they wanted to reach, advances the state
3E98: DD 7E FF    ld   a,(ix-$01)	; gets where they're going
3E9B: DD BE FD    cp   (ix-$03)		; compares it with where they've arrived
3E9E: C0          ret  nz			; if they haven't arrived where they wanted to go, exits
3E9F: DD 34 FE    inc  (ix-$02)		; otherwise advances the state
3EA2: AF          xor  a
3EA3: C9          ret

; c = mask of doors of interest among all those that can be opened
; modifies the 0x05cd table with information from the door table and between which rooms they are
3EA4: DD E5       push ix
3EA6: 3A C0 A2    ld   a,($A2C0)	; reads adso's movement data
3EA9: 32 9D 3C    ld   ($3C9D),a	; saves that value which will later be used as if it were a random value
3EAC: 3A A6 3C    ld   a,($3CA6)	; gets the mask of doors that can be opened
3EAF: A1          and  c
3EB0: 4F          ld   c,a			; c = doors the character can pass through
3EB1: DD 21 67 3C ld   ix,$3C67		; points to the table with the rooms connected by doors
3EB5: 06 06       ld   b,$06		; 6 doors
3EB7: CB 39       srl  c			; shifts c to the right
3EB9: 3E 3F       ld   a,$3F		; ccf instruction (complements the carry flag)
3EBB: 38 01       jr   c,$3EBE		; if can enter through that door, jumps
3EBD: AF          xor  a
3EBE: 32 D7 3E    ld   ($3ED7),a	; modifies an instruction
3EC1: 21 CD 05    ld   hl,$05CD		; points to the room connections on the ground floor
3EC4: DD 7E 00    ld   a,(ix+$00)	; reads the index in the ground floor room matrix
3EC7: DD 23       inc  ix
3EC9: FE FF       cp   $FF
3ECB: 28 11       jr   z,$3EDE		; if it finds 0xff moves to the next iteration
3ECD: CD 2D 16    call $162D		; hl = hl + a
3ED0: DD 7E 00    ld   a,(ix+$00)	; reads the value for that room
3ED3: DD 23       inc  ix
3ED5: 5E          ld   e,(hl)		; gets the connections of that room
3ED6: A7          and  a			; clears the carry flag
3ED7: 00          nop				; instruction modified from outside (either ccf or nop) it's ccf if the door bit was 1
3ED8: CD E3 3E    call $3EE3		; if cf = 0 (that is, if can't go to that door), a = a | e. if cf = 1 a = ~a & e
3EDB: 77          ld   (hl),a		; modifies the value of that room
3EDC: 18 E3       jr   $3EC1
3EDE: 10 D7       djnz $3EB7		; repeats until finishing the 6 entries
3EE0: DD E1       pop  ix
3EE2: C9          ret

; if there's no carry, a = a | e. If there's carry, a = ~a & e
3EE3: 30 03       jr   nc,$3EE8
3EE5: 2F          cpl
3EE6: A3          and  e
3EE7: C9          ret
3EE8: B3          or   e
3EE9: C9          ret

; ------------- code and data related to pathfinding in the same screen ----------------------------------

; tries to execute actions depending on the time of day
3EEA: 3A A2 2D    ld   a,($2DA2)	; copies the phrase/voice playback state
3EED: 32 A1 2D    ld   ($2DA1),a
3EF0: 2A 88 2D    ld   hl,($2D88)	; hl points to the data of the character shown on screen
3EF3: CB 46       bit  0,(hl)		; if in the middle of an animation, exits
3EF5: C0          ret  nz

3EF6: 3A 9A 3C    ld   a,($3C9A)	; reads if the time of day should advance
3EF9: A7          and  a
3EFA: CA F9 5E    jp   z,$5EF9		; if the time of day doesn't need to advance, tries to execute scheduled actions according to time of day

3EFD: 3A A1 2D    ld   a,($2DA1)	; if a voice is being played, exits
3F00: A7          and  a
3F01: C0          ret  nz

3F02: 32 9A 3C    ld   ($3C9A),a	; indicates that the time of day no longer needs to advance
3F05: CD 3E 55    call $553E		; advances the time of day
3F08: C3 F9 5E    jp   $5EF9		; if the time of day has changed, executes actions depending on the time of day

; puts a phrase in the marker
3F0B: CD 26 50    call $5026        ; puts in the marker the phrase indicated by the next byte
	00								; this byte is modified from outside
3F0F: C9          ret

; executes the routine at hl[c] (unless hl[c] == 0)
3F10: E1          pop  hl			; recovers the address from the stack
3F11: 06 01       ld   b,$01		; if entering with c = 0, executes the loop once
3F13: 28 03       jr   z,$3F18
3F15: 41          ld   b,c			; otherwise, executes it c times
3F16: 23          inc  hl
3F17: 23          inc  hl
3F18: 5E          ld   e,(hl)		; de = [hl]
3F19: 23          inc  hl
3F1A: 56          ld   d,(hl)
3F1B: 23          inc  hl
3F1C: 7A          ld   a,d
3F1D: B3          or   e
3F1E: 28 04       jr   z,$3F24		; if [hl] = 0, exits
3F20: 10 F6       djnz $3F18
3F22: EB          ex   de,hl
3F23: E9          jp   (hl)
3F24: E5          push hl
3F25: C9          ret

; ----------------------- code and data related to the palette -----------------------------------

; color entries (3, 2, 1, 0 and border)
3F26: 14 14 14 14 14
3F2B: 0C 14 1C 07 1C
3F30: 14 03 0E 06 14
3F35: 14 00 1D 04 14

; sets the colors of the video mode
3F3A: 21 26 3F    ld   hl,$3F26	; selects palette 0
3F3D: 18 0D       jr   $3F4C
3F3F: 21 2B 3F    ld   hl,$3F2B	; selects palette 1
3F42: 18 08       jr   $3F4C
3F44: 21 30 3F    ld   hl,$3F30	; selects palette 2
3F47: 18 03       jr   $3F4C
3F49: 21 35 3F    ld   hl,$3F35	; selects palette 3

; sets a graphics palette in mode 1
3F4C: 3E 04       ld   a,$04	; 4 colors
3F4E: 06 7F       ld   b,$7F	; pen selection
3F50: 4F          ld   c,a
3F51: 0D          dec  c
3F52: ED 49       out  (c),c	; selects color i
3F54: 4E          ld   c,(hl)	: gets the color
3F55: 23          inc  hl
3F56: CB F1       set  6,c		; sets color i with the value read (hardware color of the hardware palette)
3F58: ED 49       out  (c),c
3F5A: 3D          dec  a
3F5B: 20 F3       jr   nz,$3F50	; repeats the process

3F5D: 0E 10       ld   c,$10
3F5F: ED 49       out  (c),c	; selects the border
3F61: 4E          ld   c,(hl)
3F62: CB F1       set  6,c
3F64: ED 49       out  (c),c	; sets the border color
3F66: C9          ret

; ----------------------- end of code and data related to the palette -----------------------------------

; -------------------- code and data for the spiral effect -----------------------

; auxiliary data for drawing the square spiral
3F67: 48 54 CD C1

; routine responsible for drawing and erasing the spiral
3F6B: AF          xor  a
3F6C: DD E5       push ix
3F6E: 1E FF       ld   e,$FF
3F70: CD 7F 3F    call $3F7F		; draws the spiral
3F73: 1E 00       ld   e,$00
3F75: CD 7F 3F    call $3F7F		; erases the spiral
3F78: DD E1       pop  ix
3F7A: AF          xor  a
3F7B: 32 75 2D    ld   ($2D75),a	; indicates a screen change
3F7E: C9          ret

; draws the spiral in the color indicated by e
3F7F: 21 00 00    ld   hl,$0000			; initial position (00, 00)
3F82: DD 21 67 3F ld   ix,$3F67			; writes the helper data for drawing the square spiral
3F86: DD 36 00 3F ld   (ix+$00),$3F		; width from left to right
3F8A: DD 36 01 4F ld   (ix+$01),$4F		; height from top to bottom
3F8E: DD 36 02 3F ld   (ix+$02),$3F		; width right to left
3F92: DD 36 03 4E ld   (ix+$03),$4E		; height from bottom to top

3F96: 06 20       ld   b,$20			; 32 times
3F98: AF          xor  a				; a = 0
3F99: C5          push bc
3F9A: DD 46 00    ld   b,(ix+$00)		; reads the width counter and jumps
3F9D: 18 07       jr   $3FA6

3F9F: C5          push bc
3FA0: DD 46 00    ld   b,(ix+$00)
3FA3: DD 35 00    dec  (ix+$00)

; draws a strip (of color a) of b*8 pixels wide and 2 high (from left to right)
3FA6: DD 35 00    dec  (ix+$00)
3FA9: CD E6 3F    call $3FE6			; converts hl to screen coordinates and writes a to that line and the next
3FAC: 2C          inc  l				; moves to the next byte in X
3FAD: 10 FA       djnz $3FA9			; repeats until b = 0

; draws a strip (of color a) of 8 pixels wide and [ix+0x01]*2 high (from top to bottom)
3FAF: DD 46 01    ld   b,(ix+$01)
3FB2: DD 35 01    dec  (ix+$01)
3FB5: DD 35 01    dec  (ix+$01)
3FB8: CD E6 3F    call $3FE6			; converts hl to screen coordinates and writes a to that line and the next
3FBB: 24          inc  h				; moves to the next 2 lines in Y
3FBC: 24          inc  h
3FBD: 10 F9       djnz $3FB8

; draws a strip (of color a) of [ix+0x02]*8 pixels wide and 2 high (from right to left)
3FBF: DD 46 02    ld   b,(ix+$02)
3FC2: DD 35 02    dec  (ix+$02)
3FC5: DD 35 02    dec  (ix+$02)
3FC8: CD E6 3F    call $3FE6			; converts hl to screen coordinates and writes a to that line and the next
3FCB: 2D          dec  l				; moves back in X
3FCC: 10 FA       djnz $3FC8

; draws a strip (of color a) of 8 pixels wide and [ix+0x03]*2 high (from bottom to top)
3FCE: DD 46 03    ld   b,(ix+$03)
3FD1: DD 35 03    dec  (ix+$03)
3FD4: DD 35 03    dec  (ix+$03)
3FD7: CD E6 3F    call $3FE6			; converts hl to screen coordinates and writes a to that line and the next
3FDA: 25          dec  h				; moves to the 2 previous coordinates in Y
3FDB: 25          dec  h
3FDC: 10 F9       djnz $3FD7

3FDE: C1          pop  bc				; recovers the counter
3FDF: AB          xor  e				; changes the strip color
3FE0: 10 BD       djnz $3F9F			; repeats until done

3FE2: CD E6 3F    call $3FE6			; converts hl to screen coordinates and writes a to that line and the next
3FE5: C9          ret

; converts hl to screen coordinates and writes a to that line and the next
3FE6: E5          push hl
3FE7: C5          push bc
3FE8: F5          push af
3FE9: CD 42 3C    call $3C42		; given hl (Y,X coordinates), calculates the corresponding screen offset
3FEC: F1          pop  af
3FED: 77          ld   (hl),a		; writes a
3FEE: F5          push af
3FEF: CD 4D 3A    call $3A4D		; moves to the next screen line
3FF2: F1          pop  af
3FF3: 77          ld   (hl),a		; writes a
3FF4: C1          pop  bc
3FF5: E1          pop  hl
3FF6: C9          ret

; -------------------- end of code and data for the spiral effect -----------------------

3FF7: 3A FA 2D    ld   a,($2DFA)	; reads if malaquias has the lamp
3FFA: E6 80       and  $80
3FFC: 2A 87 3C    ld   hl,($3C87)	; gets the lamp usage time
3FFF: B4          or   h

; abadia2.bin (0x4000-0x7fff)
4000: B5          or   l
4001: C8          ret  z			; if malaquias doesn't have the lamp and it hasn't been used, exits

4002: AF          xor  a
4003: 32 91 3C    ld   ($3C91),a	; indicates that the lamp has been used
4006: 6F          ld   l,a
4007: 67          ld   h,a
4008: 22 87 3C    ld   ($3C87),hl	; sets the lamp usage counter to 0
400B: 32 8B 3C    ld   ($3C8B),a	; indicates that the lamp is not being used
400E: 21 F3 2D    ld   hl,$2DF3
4011: CB BE       res  7,(hl)		; indicates that adso doesn't have the lamp
4013: 21 FA 2D    ld   hl,$2DFA
4016: CB BE       res  7,(hl)		; indicates that malaquias doesn't have the lamp
4018: CD 45 41    call $4145		; copies to 0x3030 -> 00 00 00 00 00 (clears the lamp position data)
		3030
		00 00 00 00 00

; leaves the passage key on malaquias' table
4022: 3A FD 2D    ld   a,($2DFD)	; gets malaquias' objects
4025: CB 4F       bit  1,a
4027: C8          ret  z			; if he doesn't have the key to the passage behind the kitchen, exits
4028: E6 FD       and  $FD
402A: 32 FD 2D    ld   ($2DFD),a	; removes the key to the passage behind the kitchen
402D: CD 45 41    call $4145		; copies to 0x3026 -> 00 00 35 35 13 (puts key3 on the table)
		3026
		00 00 35 35 13

4037: 3A EF 2D    ld   a,($2DEF)	; gets the objects we have
403A: E6 DF       and  $DF
403C: 32 EF 2D    ld   ($2DEF),a	; removes the glasses from the objects we have
403F: 3A 0B 2E    ld   a,($2E0B)	; gets berengario's objects
4042: E6 DF       and  $DF
4044: 32 0B 2E    ld   ($2E0B),a	; removes the glasses from berengario
4047: DD E5       push ix
4049: CD D4 51    call $51D4		; draws the objects we have in the marker
404C: DD E1       pop  ix
404E: CD 45 41    call $4145
		3012						; copies to 0x3012 -> 00 00 00 00 00 (the glasses disappear)
		00 00 00 00 00

4058: 21 9B 30    ld   hl,$309B		; pointer to berengario's face graphic data
405B: 11 93 B2    ld   de,$B293		; pointer to bernardo gui's face graphic data
405E: CD A2 40    call $40A2		; modifies the face pointed to by hl with the one passed in de. Also calls 0x4145 with what follows
		3073						; places bernardo gui's initial position in the abbey
		00 88 88 02 00

4068: 21 9D 30    ld   hl,$309D		; pointer to severino's face graphic data
406B: 11 F7 B2    ld   de,$B2F7		; pointer to jorge's face graphic data
406E: CD A2 40    call $40A2		; modifies the face pointed to by hl with the one passed in de. Also calls 0x4145 with what follows
		3082						; places jorge's initial position in the abbey (behind the mirror)
		03 12 65 18 00

4078: 2A 7E 30    ld   hl,($307E)	; reads the address of the data guiding berengario
407B: 36 10       ld   (hl),$10		; writes the value to think a new move
407D: AF          xor  a
407E: 32 7C 30    ld   ($307C),a	; stops the counter and index of the data guiding the character
4081: 32 8C 30    ld   ($308C),a
4084: 21 9B 30    ld   hl,$309B		; pointer to berengario's face graphic data
4087: 11 F7 B2    ld   de,$B2F7		; pointer to jorge's face graphic data
408A: CD A2 40    call $40A2		; modifies the face pointed to by hl with the one passed in de. Also calls 0x4145 with what follows
		3073
		00 C8 24 00 00

4094: CD C4 36    call $36C4		; rotates the monks' graphics if necessary
4097: 21 9B 30    ld   hl,$309B		; pointer to berengario's face graphic data
409A: 11 5B B3    ld   de,$B35B		; pointer to the hooded man's face graphic data

; modifies the face pointed to by hl with the one passed in de. Also calls 0x4145 with what follows
409D: 73          ld   (hl),e		; [hl] = de
409E: 23          inc  hl
409F: 72          ld   (hl),d
40A0: 23          inc  hl
